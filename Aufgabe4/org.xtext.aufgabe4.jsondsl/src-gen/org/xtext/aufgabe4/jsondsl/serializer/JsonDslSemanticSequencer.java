/*
 * generated by Xtext 2.25.0
 */
package org.xtext.aufgabe4.jsondsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JSON_Array;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JSON_Boolean;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JSON_Document;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JSON_Member;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JSON_Number;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JSON_Object;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JSON_String;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JSON_Value;
import org.xtext.aufgabe4.jsondsl.jsonDsl.JsonDslPackage;
import org.xtext.aufgabe4.jsondsl.services.JsonDslGrammarAccess;

@SuppressWarnings("all")
public class JsonDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JsonDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JsonDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JsonDslPackage.JSON_ARRAY:
				sequence_JSON_Array(context, (JSON_Array) semanticObject); 
				return; 
			case JsonDslPackage.JSON_BOOLEAN:
				sequence_JSON_Boolean(context, (JSON_Boolean) semanticObject); 
				return; 
			case JsonDslPackage.JSON_DOCUMENT:
				sequence_JSON_Document(context, (JSON_Document) semanticObject); 
				return; 
			case JsonDslPackage.JSON_MEMBER:
				sequence_JSON_Member(context, (JSON_Member) semanticObject); 
				return; 
			case JsonDslPackage.JSON_NUMBER:
				sequence_JSON_Number(context, (JSON_Number) semanticObject); 
				return; 
			case JsonDslPackage.JSON_OBJECT:
				sequence_JSON_Object(context, (JSON_Object) semanticObject); 
				return; 
			case JsonDslPackage.JSON_STRING:
				sequence_JSON_String(context, (JSON_String) semanticObject); 
				return; 
			case JsonDslPackage.JSON_VALUE:
				sequence_JSON_Value(context, (JSON_Value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     JSON_Array returns JSON_Array
	 *
	 * Constraint:
	 *     (first=JSON_Value other+=JSON_Value*)
	 */
	protected void sequence_JSON_Array(ISerializationContext context, JSON_Array semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JSON_Boolean returns JSON_Boolean
	 *
	 * Constraint:
	 *     (json_boolean='true' | json_boolean='false' | json_boolean='null')
	 */
	protected void sequence_JSON_Boolean(ISerializationContext context, JSON_Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JSON_Document returns JSON_Document
	 *
	 * Constraint:
	 *     json_value=JSON_Value
	 */
	protected void sequence_JSON_Document(ISerializationContext context, JSON_Document semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonDslPackage.Literals.JSON_DOCUMENT__JSON_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonDslPackage.Literals.JSON_DOCUMENT__JSON_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJSON_DocumentAccess().getJson_valueJSON_ValueParserRuleCall_0(), semanticObject.getJson_value());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JSON_Member returns JSON_Member
	 *
	 * Constraint:
	 *     (json_member=JSON_String json_value=JSON_Value)
	 */
	protected void sequence_JSON_Member(ISerializationContext context, JSON_Member semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonDslPackage.Literals.JSON_MEMBER__JSON_MEMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonDslPackage.Literals.JSON_MEMBER__JSON_MEMBER));
			if (transientValues.isValueTransient(semanticObject, JsonDslPackage.Literals.JSON_MEMBER__JSON_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonDslPackage.Literals.JSON_MEMBER__JSON_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJSON_MemberAccess().getJson_memberJSON_StringParserRuleCall_0_0(), semanticObject.getJson_member());
		feeder.accept(grammarAccess.getJSON_MemberAccess().getJson_valueJSON_ValueParserRuleCall_2_0(), semanticObject.getJson_value());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JSON_Number returns JSON_Number
	 *
	 * Constraint:
	 *     ((zahl=INT? komma=INT expo=INT) | (zahl=INT? expo=INT) | expo=INT)?
	 */
	protected void sequence_JSON_Number(ISerializationContext context, JSON_Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JSON_Object returns JSON_Object
	 *
	 * Constraint:
	 *     (first=JSON_Member other+=JSON_Member*)
	 */
	protected void sequence_JSON_Object(ISerializationContext context, JSON_Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     JSON_String returns JSON_String
	 *
	 * Constraint:
	 *     json_string=STRING
	 */
	protected void sequence_JSON_String(ISerializationContext context, JSON_String semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JsonDslPackage.Literals.JSON_STRING__JSON_STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JsonDslPackage.Literals.JSON_STRING__JSON_STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJSON_StringAccess().getJson_stringSTRINGTerminalRuleCall_0(), semanticObject.getJson_string());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JSON_Value returns JSON_Value
	 *
	 * Constraint:
	 *     (json_value=JSON_Array | json_value=JSON_String | json_value=JSON_Boolean | json_value=JSON_Number | json_value=JSON_Object)
	 */
	protected void sequence_JSON_Value(ISerializationContext context, JSON_Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
